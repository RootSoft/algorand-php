<?php


namespace Rootsoft\Algorand\Mnemonic;

use Rootsoft\Algorand\Exceptions\MnemonicException;
use Rootsoft\Algorand\Exceptions\WordListException;

/**
 * On the Algorand blockchain chain, mnemonic keys are generated by converting the user's private key string
 * to an 11-bit integer to the bip-0039 English word list where the integer value maps to the word in the bip-0039
 * English word list with position same as the integer value.
 *
 * To illustrate, if an integer value is 2, it will map to the 2nd word on the bip-0039 English word list.
 * This process of transforming the private keys to 11-bit integer and mapping it to bip-0039 English word list will
 * generate 24-word mnemonic keys.
 * The bip-0039 English word is made up of about 2048 random words in an array and can also be termed as seed phrase.
 *
 * A checksum is added by taking the first two bytes of the hash of the private key and converting them to 11-bit
 * integers and then to their corresponding word in the word list. This word is added to the end of the 24 words to
 * create a 25-word mnemonic.
 *
 * Code is based on BIP39 by Furqan Siddiqui.
 * Credits belong to:
 * https://github.com/furqansiddiqui/bip39-mnemonic-php
 *
 * Class Mnemonic
 * @package Rootsoft\Algorand\Mnemonic
 */
class Mnemonic
{
    public const VERSION = "0.1.2";
    public const BITS_PER_WORD = 11;
    public const KEY_LEN_BYTES = 32;

    public const ALGORAND_WORD_COUNT = 25;

    /** @var int */
    private $wordsCount;

    /** @var null|string */
    private $entropy;

    /** @var null|string */
    private $checksum;

    /** @var null|array */
    private $rawBinaryChunks;

    /** @var null|array */
    private $words;

    /** @var null|WordList */
    private $wordList;

    /**
     * @param string $entropy
     * @return SeedPhrase
     * @throws MnemonicException
     * @throws WordListException
     */
    public static function Entropy(string $entropy): SeedPhrase
    {
        self::validateEntropy($entropy);

        return (new self(self::ALGORAND_WORD_COUNT))
            ->useEntropy($entropy)
            ->wordlist(WordList::English())
            ->mnemonic();
    }

    /**
     * Find the seed of a given seedphrase/mnemonic (25 words).
     *
     * @param $words
     * @param WordList|null $wordList
     * @return SeedPhrase
     * @throws MnemonicException
     * @throws WordListException
     */
    public static function Words($words, ?WordList $wordList = null): SeedPhrase
    {
        if (is_string($words)) {
            $words = explode(" ", $words);
        }

        if (! is_array($words)) {
            throw new MnemonicException('Mnemonic constructor requires an Array of words');
        }

        $wordCount = count($words);

        return (new self($wordCount))
            ->wordlist($wordList ?? WordList::English())
            ->reverse($words);
    }

    /**
     * Mnemonic constructor.
     * @param int $wordCount
     * @throws MnemonicException
     */
    public function __construct(int $wordCount = 25)
    {
        if ($wordCount != self::ALGORAND_WORD_COUNT) {
            throw new MnemonicException('Mnemonic words count must be 25');
        }

        // Actual words count
        $this->wordsCount = $wordCount;
    }

    /**
     * @param string $entropy
     * @return Mnemonic
     * @throws MnemonicException
     */
    public function useEntropy(string $entropy): self
    {
        self::validateEntropy($entropy);
        $this->entropy = $entropy;
        $this->checksum = $this->checksum(hex2bin($this->entropy));
        $this->rawBinaryChunks = self::toUintNArray(unpack('C*', hex2bin($this->entropy)));

        return $this;
    }

    /**
     * @return SeedPhrase
     * @throws MnemonicException
     */
    public function mnemonic(): SeedPhrase
    {
        if (! $this->entropy) {
            throw new MnemonicException('Entropy is not defined');
        }

        if (! $this->wordList) {
            throw new MnemonicException('Word list is not defined');
        }

        $mnemonic = new SeedPhrase($this->entropy);
        foreach ($this->rawBinaryChunks as $index) {
            $mnemonic->wordsIndex[] = $index;
            $mnemonic->words[] = $this->wordList->getWord($index);
            $mnemonic->rawBinaryChunks[] = $index;
            $mnemonic->wordsCount++;
        }

        // Checksum
        $checksum = self::toUintNArray(unpack('C*', $this->checksum))[0];

        $mnemonic->wordsIndex[] = $checksum;
        $mnemonic->words[] = $this->wordList->getWord($checksum);
        $mnemonic->wordsCount++;

        return $mnemonic;
    }

    /**
     * @param WordList $wordList
     * @return Mnemonic
     */
    public function wordList(WordList $wordList): self
    {
        $this->wordList = $wordList;

        return $this;
    }

    /**
     * @param array $words
     * @return SeedPhrase
     * @throws MnemonicException
     * @throws WordListException
     */
    public function reverse(array $words)
    {
        if (! $this->wordList) {
            throw new MnemonicException('Wordlist is not defined');
        }

        // Extract the checksum word from the mnemonic
        $checksumWord = $words[self::ALGORAND_WORD_COUNT - 1];
        $words = array_slice($words, 0, self::ALGORAND_WORD_COUNT - 1, true);

        $seedPhrase = new SeedPhrase();
        $pos = 0;
        foreach ($words as $word) {
            $pos++;
            $index = $this->wordList->findIndex($word);
            if (is_null($index)) {
                throw new WordListException(sprintf('Invalid/unknown word at position %d', $pos));
            }

            $seedPhrase->words[] = $word;
            $seedPhrase->wordsIndex[] = $index;
            $seedPhrase->wordsCount++;
            $seedPhrase->rawBinaryChunks[] = $index;
        }

        // 11 bit int to 8 bit int
        $b = self::toByteArray($seedPhrase->rawBinaryChunks);
        if (count($b) != self::KEY_LEN_BYTES + 1) {
            throw new MnemonicException('Wrong key length');
        }

        if ($b[self::KEY_LEN_BYTES] != 0) {
            throw new MnemonicException('Unexpected byte from key');
        }

        // Chop the last byte. The last byte was 3 bits, padded with 8 bits to create the 24th word.
        array_pop($b);

        // Pack the bytearray to a binary string
        $entropy = pack('C*', ...$b);

        // Verify Checksum
        $computedChecksum = $this->getChecksumWord($entropy);
        if ($checksumWord != $computedChecksum) {
            throw new MnemonicException('Checksums do not match.');
        }

        $seedPhrase->entropy = bin2hex($entropy);

        return $seedPhrase;
    }

    /**
     * Get the word for the given checksum.
     * @param string $entropy The binary representation of the entropy.
     * @return string
     */
    private function getChecksumWord(string $entropy)
    {
        $checksumBytes = $this->checksum($entropy);
        $checksumIndex = self::toUintNArray(unpack('C*', $checksumBytes))[0]; // Get first byte

        return $this->wordList->getWord($checksumIndex);
    }

    /**
     * @param string $entropy
     * @param int $bits
     * @return string
     */
    private function checksum(string $entropy): string
    {
        // Compute the hash
        $hashedAddress = hash('sha512/256', $entropy, true);

        // Take the first 2 bytes
        $checksum = substr($hashedAddress, 0, 2);

        return $checksum;
    }

    private static function toUintNArray(array $arr)
    {
        $buffer = 0;
        $numBits = 0;
        $j = 0;

        $out = [];

        for ($i = 1; $i < count($arr) + 1; $i++) {
            $v = $arr[$i];
            $buffer |= ($v << $numBits);
            $numBits += 8;
            if ($numBits >= self::BITS_PER_WORD) {
                // add to output
                $out[$j] = $buffer & 0x7ff;
                $j++;

                // drop from buffer
                $buffer = $buffer >> self::BITS_PER_WORD;
                $numBits -= self::BITS_PER_WORD;
            }
        }

        if ($numBits != 0) {
            $out[$j] = $buffer & 0x7ff;
        }

        return $out;
    }

    /**
     * Turn an unsigned 11bit integer array to a byte array
     * @param array $arr
     * @return array
     */
    private static function toByteArray(array $arr)
    {
        $buffer = 0;
        $numBits = 0;
        $j = 0;

        $out = [];
        for ($i = 0; $i < count($arr); $i++) {
            $v = $arr[$i];
            $buffer |= ($v << $numBits);
            $numBits += self::BITS_PER_WORD;
            while ($numBits >= 8) {
                // add to output
                $out[$j] = $buffer & 0x7ff;
                $j++;

                // drop from buffer
                $buffer = $buffer >> 8;
                $numBits -= 8;
            }
        }

        if ($numBits != 0) {
            $out[$j] = $buffer & 0x7ff;
        }

        return $out;
    }

    /**
     * @param string $entropy
     * @throws MnemonicException
     */
    private static function validateEntropy(string $entropy): void
    {
        if (! preg_match('/^[a-f0-9]{2,}$/', $entropy)) {
            throw new MnemonicException('Invalid entropy (requires hexadecimal)');
        }

        $entropyBits = strlen($entropy) * 4;

        if (! in_array($entropyBits, [256])) {
            throw new MnemonicException('Invalid entropy length');
        }
    }
}
