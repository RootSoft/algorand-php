<?php
/**
 * DefaultApi
 * PHP version 7.3.
 *
 * @category Class
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * for KMD HTTP API.
 *
 * API for KMD (Key Management Daemon)
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Rootsoft\Algorand\KMD\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Rootsoft\Algorand\KMD\ApiException;
use Rootsoft\Algorand\KMD\Configuration;
use Rootsoft\Algorand\KMD\HeaderSelector;
use Rootsoft\Algorand\KMD\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment.
 *
 * @category Class
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class KmdApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index.
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index.
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createWallet.
     *
     * Create a wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\CreateWalletRequest $create_wallet_request create_wallet_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTWalletResponse
     */
    public function createWallet($create_wallet_request)
    {
        list($response) = $this->createWalletWithHttpInfo($create_wallet_request);

        return $response;
    }

    /**
     * Operation createWalletWithHttpInfo.
     *
     * Create a wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\CreateWalletRequest $create_wallet_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTWalletResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWalletWithHttpInfo($create_wallet_request)
    {
        $request = $this->createWalletRequest($create_wallet_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation createWalletAsync.
     *
     * Create a wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\CreateWalletRequest $create_wallet_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWalletAsync($create_wallet_request)
    {
        return $this->createWalletAsyncWithHttpInfo($create_wallet_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createWalletAsyncWithHttpInfo.
     *
     * Create a wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\CreateWalletRequest $create_wallet_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWalletAsyncWithHttpInfo($create_wallet_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletResponse';
        $request = $this->createWalletRequest($create_wallet_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createWallet'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\CreateWalletRequest $create_wallet_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createWalletRequest($create_wallet_request)
    {
        // verify the required parameter 'create_wallet_request' is set
        if ($create_wallet_request === null || (is_array($create_wallet_request) && count($create_wallet_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_wallet_request when calling createWallet'
            );
        }

        $resourcePath = '/v1/wallet';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($create_wallet_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_wallet_request));
            } else {
                $httpBody = $create_wallet_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteKey.
     *
     * Delete a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\DeleteKeyRequest $delete_key_request delete_key_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1DELETEKeyResponse
     */
    public function deleteKey($delete_key_request)
    {
        list($response) = $this->deleteKeyWithHttpInfo($delete_key_request);

        return $response;
    }

    /**
     * Operation deleteKeyWithHttpInfo.
     *
     * Delete a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\DeleteKeyRequest $delete_key_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1DELETEKeyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteKeyWithHttpInfo($delete_key_request)
    {
        $request = $this->deleteKeyRequest($delete_key_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1DELETEKeyResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1DELETEKeyResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1DELETEKeyResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1DELETEKeyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteKeyAsync.
     *
     * Delete a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\DeleteKeyRequest $delete_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKeyAsync($delete_key_request)
    {
        return $this->deleteKeyAsyncWithHttpInfo($delete_key_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteKeyAsyncWithHttpInfo.
     *
     * Delete a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\DeleteKeyRequest $delete_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKeyAsyncWithHttpInfo($delete_key_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1DELETEKeyResponse';
        $request = $this->deleteKeyRequest($delete_key_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteKey'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\DeleteKeyRequest $delete_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteKeyRequest($delete_key_request)
    {
        // verify the required parameter 'delete_key_request' is set
        if ($delete_key_request === null || (is_array($delete_key_request) && count($delete_key_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delete_key_request when calling deleteKey'
            );
        }

        $resourcePath = '/v1/key';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($delete_key_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($delete_key_request));
            } else {
                $httpBody = $delete_key_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMultisig.
     *
     * Delete a multisig
     *
     * @param  \Rootsoft\Algorand\KMD\Model\DeleteMultisigRequest $delete_multisig_request delete_multisig_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1DELETEMultisigResponse
     */
    public function deleteMultisig($delete_multisig_request)
    {
        list($response) = $this->deleteMultisigWithHttpInfo($delete_multisig_request);

        return $response;
    }

    /**
     * Operation deleteMultisigWithHttpInfo.
     *
     * Delete a multisig
     *
     * @param  \Rootsoft\Algorand\KMD\Model\DeleteMultisigRequest $delete_multisig_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1DELETEMultisigResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMultisigWithHttpInfo($delete_multisig_request)
    {
        $request = $this->deleteMultisigRequest($delete_multisig_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1DELETEMultisigResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1DELETEMultisigResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1DELETEMultisigResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1DELETEMultisigResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteMultisigAsync.
     *
     * Delete a multisig
     *
     * @param  \Rootsoft\Algorand\KMD\Model\DeleteMultisigRequest $delete_multisig_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMultisigAsync($delete_multisig_request)
    {
        return $this->deleteMultisigAsyncWithHttpInfo($delete_multisig_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMultisigAsyncWithHttpInfo.
     *
     * Delete a multisig
     *
     * @param  \Rootsoft\Algorand\KMD\Model\DeleteMultisigRequest $delete_multisig_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMultisigAsyncWithHttpInfo($delete_multisig_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1DELETEMultisigResponse';
        $request = $this->deleteMultisigRequest($delete_multisig_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMultisig'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\DeleteMultisigRequest $delete_multisig_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteMultisigRequest($delete_multisig_request)
    {
        // verify the required parameter 'delete_multisig_request' is set
        if ($delete_multisig_request === null || (is_array($delete_multisig_request) && count($delete_multisig_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delete_multisig_request when calling deleteMultisig'
            );
        }

        $resourcePath = '/v1/multisig';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($delete_multisig_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($delete_multisig_request));
            } else {
                $httpBody = $delete_multisig_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation exportKey.
     *
     * Export a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportKeyRequest $export_key_request export_key_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTKeyExportResponse
     */
    public function exportKey($export_key_request)
    {
        list($response) = $this->exportKeyWithHttpInfo($export_key_request);

        return $response;
    }

    /**
     * Operation exportKeyWithHttpInfo.
     *
     * Export a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportKeyRequest $export_key_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTKeyExportResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportKeyWithHttpInfo($export_key_request)
    {
        $request = $this->exportKeyRequest($export_key_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyExportResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyExportResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyExportResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyExportResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation exportKeyAsync.
     *
     * Export a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportKeyRequest $export_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportKeyAsync($export_key_request)
    {
        return $this->exportKeyAsyncWithHttpInfo($export_key_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportKeyAsyncWithHttpInfo.
     *
     * Export a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportKeyRequest $export_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportKeyAsyncWithHttpInfo($export_key_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyExportResponse';
        $request = $this->exportKeyRequest($export_key_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'exportKey'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportKeyRequest $export_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function exportKeyRequest($export_key_request)
    {
        // verify the required parameter 'export_key_request' is set
        if ($export_key_request === null || (is_array($export_key_request) && count($export_key_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_key_request when calling exportKey'
            );
        }

        $resourcePath = '/v1/key/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($export_key_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($export_key_request));
            } else {
                $httpBody = $export_key_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation exportMasterKey.
     *
     * Export the master derivation key from a wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportMasterKeyRequest $export_master_key_request export_master_key_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTMasterKeyExportResponse
     */
    public function exportMasterKey($export_master_key_request)
    {
        list($response) = $this->exportMasterKeyWithHttpInfo($export_master_key_request);

        return $response;
    }

    /**
     * Operation exportMasterKeyWithHttpInfo.
     *
     * Export the master derivation key from a wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportMasterKeyRequest $export_master_key_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTMasterKeyExportResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportMasterKeyWithHttpInfo($export_master_key_request)
    {
        $request = $this->exportMasterKeyRequest($export_master_key_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTMasterKeyExportResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTMasterKeyExportResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTMasterKeyExportResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTMasterKeyExportResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation exportMasterKeyAsync.
     *
     * Export the master derivation key from a wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportMasterKeyRequest $export_master_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportMasterKeyAsync($export_master_key_request)
    {
        return $this->exportMasterKeyAsyncWithHttpInfo($export_master_key_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportMasterKeyAsyncWithHttpInfo.
     *
     * Export the master derivation key from a wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportMasterKeyRequest $export_master_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportMasterKeyAsyncWithHttpInfo($export_master_key_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTMasterKeyExportResponse';
        $request = $this->exportMasterKeyRequest($export_master_key_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'exportMasterKey'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportMasterKeyRequest $export_master_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function exportMasterKeyRequest($export_master_key_request)
    {
        // verify the required parameter 'export_master_key_request' is set
        if ($export_master_key_request === null || (is_array($export_master_key_request) && count($export_master_key_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_master_key_request when calling exportMasterKey'
            );
        }

        $resourcePath = '/v1/master-key/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($export_master_key_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($export_master_key_request));
            } else {
                $httpBody = $export_master_key_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation exportMultisig.
     *
     * Export multisig address metadata
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportMultisigRequest $export_multisig_request export_multisig_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigExportResponse
     */
    public function exportMultisig($export_multisig_request)
    {
        list($response) = $this->exportMultisigWithHttpInfo($export_multisig_request);

        return $response;
    }

    /**
     * Operation exportMultisigWithHttpInfo.
     *
     * Export multisig address metadata
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportMultisigRequest $export_multisig_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigExportResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportMultisigWithHttpInfo($export_multisig_request)
    {
        $request = $this->exportMultisigRequest($export_multisig_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigExportResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigExportResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigExportResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigExportResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation exportMultisigAsync.
     *
     * Export multisig address metadata
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportMultisigRequest $export_multisig_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportMultisigAsync($export_multisig_request)
    {
        return $this->exportMultisigAsyncWithHttpInfo($export_multisig_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportMultisigAsyncWithHttpInfo.
     *
     * Export multisig address metadata
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportMultisigRequest $export_multisig_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportMultisigAsyncWithHttpInfo($export_multisig_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigExportResponse';
        $request = $this->exportMultisigRequest($export_multisig_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'exportMultisig'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ExportMultisigRequest $export_multisig_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function exportMultisigRequest($export_multisig_request)
    {
        // verify the required parameter 'export_multisig_request' is set
        if ($export_multisig_request === null || (is_array($export_multisig_request) && count($export_multisig_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_multisig_request when calling exportMultisig'
            );
        }

        $resourcePath = '/v1/multisig/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($export_multisig_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($export_multisig_request));
            } else {
                $httpBody = $export_multisig_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateKey.
     *
     * Generate a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\GenerateKeyRequest $generate_key_request generate_key_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTKeyResponse
     */
    public function generateKey($generate_key_request)
    {
        list($response) = $this->generateKeyWithHttpInfo($generate_key_request);

        return $response;
    }

    /**
     * Operation generateKeyWithHttpInfo.
     *
     * Generate a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\GenerateKeyRequest $generate_key_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTKeyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateKeyWithHttpInfo($generate_key_request)
    {
        $request = $this->generateKeyRequest($generate_key_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation generateKeyAsync.
     *
     * Generate a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\GenerateKeyRequest $generate_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateKeyAsync($generate_key_request)
    {
        return $this->generateKeyAsyncWithHttpInfo($generate_key_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateKeyAsyncWithHttpInfo.
     *
     * Generate a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\GenerateKeyRequest $generate_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateKeyAsyncWithHttpInfo($generate_key_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyResponse';
        $request = $this->generateKeyRequest($generate_key_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateKey'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\GenerateKeyRequest $generate_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generateKeyRequest($generate_key_request)
    {
        // verify the required parameter 'generate_key_request' is set
        if ($generate_key_request === null || (is_array($generate_key_request) && count($generate_key_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $generate_key_request when calling generateKey'
            );
        }

        $resourcePath = '/v1/key';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($generate_key_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($generate_key_request));
            } else {
                $httpBody = $generate_key_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVersion.
     *
     * Retrieves the current version
     *
     * @param  object $versions_request versions_request (optional)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\VersionsResponse
     */
    public function getVersion($versions_request = null)
    {
        list($response) = $this->getVersionWithHttpInfo($versions_request);

        return $response;
    }

    /**
     * Operation getVersionWithHttpInfo.
     *
     * Retrieves the current version
     *
     * @param  object $versions_request (optional)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\VersionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVersionWithHttpInfo($versions_request = null)
    {
        $request = $this->getVersionRequest($versions_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\VersionsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\VersionsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\VersionsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\VersionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getVersionAsync.
     *
     * Retrieves the current version
     *
     * @param  object $versions_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVersionAsync($versions_request = null)
    {
        return $this->getVersionAsyncWithHttpInfo($versions_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVersionAsyncWithHttpInfo.
     *
     * Retrieves the current version
     *
     * @param  object $versions_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVersionAsyncWithHttpInfo($versions_request = null)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\VersionsResponse';
        $request = $this->getVersionRequest($versions_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVersion'.
     *
     * @param  object $versions_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVersionRequest($versions_request = null)
    {
        $resourcePath = '/versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($versions_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($versions_request));
            } else {
                $httpBody = $versions_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWalletInfo.
     *
     * Get wallet info
     *
     * @param  \Rootsoft\Algorand\KMD\Model\WalletInfoRequest $get_wallet_info_request get_wallet_info_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInfoResponse
     */
    public function getWalletInfo($get_wallet_info_request)
    {
        list($response) = $this->getWalletInfoWithHttpInfo($get_wallet_info_request);

        return $response;
    }

    /**
     * Operation getWalletInfoWithHttpInfo.
     *
     * Get wallet info
     *
     * @param  \Rootsoft\Algorand\KMD\Model\WalletInfoRequest $get_wallet_info_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWalletInfoWithHttpInfo($get_wallet_info_request)
    {
        $request = $this->getWalletInfoRequest($get_wallet_info_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInfoResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInfoResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInfoResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getWalletInfoAsync.
     *
     * Get wallet info
     *
     * @param  \Rootsoft\Algorand\KMD\Model\WalletInfoRequest $get_wallet_info_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWalletInfoAsync($get_wallet_info_request)
    {
        return $this->getWalletInfoAsyncWithHttpInfo($get_wallet_info_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWalletInfoAsyncWithHttpInfo.
     *
     * Get wallet info
     *
     * @param  \Rootsoft\Algorand\KMD\Model\WalletInfoRequest $get_wallet_info_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWalletInfoAsyncWithHttpInfo($get_wallet_info_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInfoResponse';
        $request = $this->getWalletInfoRequest($get_wallet_info_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWalletInfo'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\WalletInfoRequest $get_wallet_info_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWalletInfoRequest($get_wallet_info_request)
    {
        // verify the required parameter 'get_wallet_info_request' is set
        if ($get_wallet_info_request === null || (is_array($get_wallet_info_request) && count($get_wallet_info_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $get_wallet_info_request when calling getWalletInfo'
            );
        }

        $resourcePath = '/v1/wallet/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($get_wallet_info_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($get_wallet_info_request));
            } else {
                $httpBody = $get_wallet_info_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importKey.
     *
     * Import a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ImportKeyRequest $import_key_request import_key_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTKeyImportResponse
     */
    public function importKey($import_key_request)
    {
        list($response) = $this->importKeyWithHttpInfo($import_key_request);

        return $response;
    }

    /**
     * Operation importKeyWithHttpInfo.
     *
     * Import a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ImportKeyRequest $import_key_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTKeyImportResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function importKeyWithHttpInfo($import_key_request)
    {
        $request = $this->importKeyRequest($import_key_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyImportResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyImportResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyImportResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyImportResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation importKeyAsync.
     *
     * Import a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ImportKeyRequest $import_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importKeyAsync($import_key_request)
    {
        return $this->importKeyAsyncWithHttpInfo($import_key_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importKeyAsyncWithHttpInfo.
     *
     * Import a key
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ImportKeyRequest $import_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importKeyAsyncWithHttpInfo($import_key_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyImportResponse';
        $request = $this->importKeyRequest($import_key_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importKey'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ImportKeyRequest $import_key_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importKeyRequest($import_key_request)
    {
        // verify the required parameter 'import_key_request' is set
        if ($import_key_request === null || (is_array($import_key_request) && count($import_key_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_key_request when calling importKey'
            );
        }

        $resourcePath = '/v1/key/import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($import_key_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($import_key_request));
            } else {
                $httpBody = $import_key_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importMultisig.
     *
     * Import a multisig account
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ImportMultisigRequest $import_multisig_request import_multisig_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigImportResponse
     */
    public function importMultisig($import_multisig_request)
    {
        list($response) = $this->importMultisigWithHttpInfo($import_multisig_request);

        return $response;
    }

    /**
     * Operation importMultisigWithHttpInfo.
     *
     * Import a multisig account
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ImportMultisigRequest $import_multisig_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigImportResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function importMultisigWithHttpInfo($import_multisig_request)
    {
        $request = $this->importMultisigRequest($import_multisig_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigImportResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigImportResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigImportResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigImportResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation importMultisigAsync.
     *
     * Import a multisig account
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ImportMultisigRequest $import_multisig_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importMultisigAsync($import_multisig_request)
    {
        return $this->importMultisigAsyncWithHttpInfo($import_multisig_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importMultisigAsyncWithHttpInfo.
     *
     * Import a multisig account
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ImportMultisigRequest $import_multisig_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importMultisigAsyncWithHttpInfo($import_multisig_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigImportResponse';
        $request = $this->importMultisigRequest($import_multisig_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importMultisig'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ImportMultisigRequest $import_multisig_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importMultisigRequest($import_multisig_request)
    {
        // verify the required parameter 'import_multisig_request' is set
        if ($import_multisig_request === null || (is_array($import_multisig_request) && count($import_multisig_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_multisig_request when calling importMultisig'
            );
        }

        $resourcePath = '/v1/multisig/import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($import_multisig_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($import_multisig_request));
            } else {
                $httpBody = $import_multisig_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation initWalletHandleToken.
     *
     * Initialize a wallet handle token
     *
     * @param  \Rootsoft\Algorand\KMD\Model\InitWalletHandleTokenRequest $initialize_wallet_handle_token_request initialize_wallet_handle_token_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInitResponse
     */
    public function initWalletHandleToken($initialize_wallet_handle_token_request)
    {
        list($response) = $this->initWalletHandleTokenWithHttpInfo($initialize_wallet_handle_token_request);

        return $response;
    }

    /**
     * Operation initWalletHandleTokenWithHttpInfo.
     *
     * Initialize a wallet handle token
     *
     * @param  \Rootsoft\Algorand\KMD\Model\InitWalletHandleTokenRequest $initialize_wallet_handle_token_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInitResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function initWalletHandleTokenWithHttpInfo($initialize_wallet_handle_token_request)
    {
        $request = $this->initWalletHandleTokenRequest($initialize_wallet_handle_token_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInitResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInitResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInitResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInitResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation initWalletHandleTokenAsync.
     *
     * Initialize a wallet handle token
     *
     * @param  \Rootsoft\Algorand\KMD\Model\InitWalletHandleTokenRequest $initialize_wallet_handle_token_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function initWalletHandleTokenAsync($initialize_wallet_handle_token_request)
    {
        return $this->initWalletHandleTokenAsyncWithHttpInfo($initialize_wallet_handle_token_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation initWalletHandleTokenAsyncWithHttpInfo.
     *
     * Initialize a wallet handle token
     *
     * @param  \Rootsoft\Algorand\KMD\Model\InitWalletHandleTokenRequest $initialize_wallet_handle_token_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function initWalletHandleTokenAsyncWithHttpInfo($initialize_wallet_handle_token_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletInitResponse';
        $request = $this->initWalletHandleTokenRequest($initialize_wallet_handle_token_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'initWalletHandleToken'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\InitWalletHandleTokenRequest $initialize_wallet_handle_token_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function initWalletHandleTokenRequest($initialize_wallet_handle_token_request)
    {
        // verify the required parameter 'initialize_wallet_handle_token_request' is set
        if ($initialize_wallet_handle_token_request === null || (is_array($initialize_wallet_handle_token_request) && count($initialize_wallet_handle_token_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $initialize_wallet_handle_token_request when calling initWalletHandleToken'
            );
        }

        $resourcePath = '/v1/wallet/init';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($initialize_wallet_handle_token_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($initialize_wallet_handle_token_request));
            } else {
                $httpBody = $initialize_wallet_handle_token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listKeysInWallet.
     *
     * List keys in wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ListKeysRequest $list_keys_request list_keys_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTKeyListResponse
     */
    public function listKeysInWallet($list_keys_request)
    {
        list($response) = $this->listKeysInWalletWithHttpInfo($list_keys_request);

        return $response;
    }

    /**
     * Operation listKeysInWalletWithHttpInfo.
     *
     * List keys in wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ListKeysRequest $list_keys_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTKeyListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listKeysInWalletWithHttpInfo($list_keys_request)
    {
        $request = $this->listKeysInWalletRequest($list_keys_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listKeysInWalletAsync.
     *
     * List keys in wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ListKeysRequest $list_keys_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listKeysInWalletAsync($list_keys_request)
    {
        return $this->listKeysInWalletAsyncWithHttpInfo($list_keys_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listKeysInWalletAsyncWithHttpInfo.
     *
     * List keys in wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ListKeysRequest $list_keys_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listKeysInWalletAsyncWithHttpInfo($list_keys_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTKeyListResponse';
        $request = $this->listKeysInWalletRequest($list_keys_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listKeysInWallet'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ListKeysRequest $list_keys_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listKeysInWalletRequest($list_keys_request)
    {
        // verify the required parameter 'list_keys_request' is set
        if ($list_keys_request === null || (is_array($list_keys_request) && count($list_keys_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $list_keys_request when calling listKeysInWallet'
            );
        }

        $resourcePath = '/v1/key/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($list_keys_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($list_keys_request));
            } else {
                $httpBody = $list_keys_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMultisg.
     *
     * List multisig accounts
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ListMultisigRequest $list_multisig_request list_multisig_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigListResponse
     */
    public function listMultisg($list_multisig_request)
    {
        list($response) = $this->listMultisgWithHttpInfo($list_multisig_request);

        return $response;
    }

    /**
     * Operation listMultisgWithHttpInfo.
     *
     * List multisig accounts
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ListMultisigRequest $list_multisig_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMultisgWithHttpInfo($list_multisig_request)
    {
        $request = $this->listMultisgRequest($list_multisig_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listMultisgAsync.
     *
     * List multisig accounts
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ListMultisigRequest $list_multisig_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMultisgAsync($list_multisig_request)
    {
        return $this->listMultisgAsyncWithHttpInfo($list_multisig_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMultisgAsyncWithHttpInfo.
     *
     * List multisig accounts
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ListMultisigRequest $list_multisig_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMultisgAsyncWithHttpInfo($list_multisig_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigListResponse';
        $request = $this->listMultisgRequest($list_multisig_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMultisg'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ListMultisigRequest $list_multisig_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMultisgRequest($list_multisig_request)
    {
        // verify the required parameter 'list_multisig_request' is set
        if ($list_multisig_request === null || (is_array($list_multisig_request) && count($list_multisig_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $list_multisig_request when calling listMultisg'
            );
        }

        $resourcePath = '/v1/multisig/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($list_multisig_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($list_multisig_request));
            } else {
                $httpBody = $list_multisig_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listWallets.
     *
     * List wallets
     *
     * @param  object $list_wallet_request list_wallet_request (optional)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1GETWalletsResponse
     */
    public function listWallets($list_wallet_request = null)
    {
        list($response) = $this->listWalletsWithHttpInfo($list_wallet_request);

        return $response;
    }

    /**
     * Operation listWalletsWithHttpInfo.
     *
     * List wallets
     *
     * @param  object $list_wallet_request (optional)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1GETWalletsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listWalletsWithHttpInfo($list_wallet_request = null)
    {
        $request = $this->listWalletsRequest($list_wallet_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1GETWalletsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1GETWalletsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1GETWalletsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1GETWalletsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listWalletsAsync.
     *
     * List wallets
     *
     * @param  object $list_wallet_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWalletsAsync($list_wallet_request = null)
    {
        return $this->listWalletsAsyncWithHttpInfo($list_wallet_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listWalletsAsyncWithHttpInfo.
     *
     * List wallets
     *
     * @param  object $list_wallet_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWalletsAsyncWithHttpInfo($list_wallet_request = null)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1GETWalletsResponse';
        $request = $this->listWalletsRequest($list_wallet_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listWallets'.
     *
     * @param  object $list_wallet_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listWalletsRequest($list_wallet_request = null)
    {
        $resourcePath = '/v1/wallets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($list_wallet_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($list_wallet_request));
            } else {
                $httpBody = $list_wallet_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releaseWalletHandleToken.
     *
     * Release a wallet handle token
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ReleaseWalletHandleTokenRequest $release_wallet_handle_token_request release_wallet_handle_token_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTWalletReleaseResponse
     */
    public function releaseWalletHandleToken($release_wallet_handle_token_request)
    {
        list($response) = $this->releaseWalletHandleTokenWithHttpInfo($release_wallet_handle_token_request);

        return $response;
    }

    /**
     * Operation releaseWalletHandleTokenWithHttpInfo.
     *
     * Release a wallet handle token
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ReleaseWalletHandleTokenRequest $release_wallet_handle_token_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTWalletReleaseResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function releaseWalletHandleTokenWithHttpInfo($release_wallet_handle_token_request)
    {
        $request = $this->releaseWalletHandleTokenRequest($release_wallet_handle_token_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletReleaseResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletReleaseResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletReleaseResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletReleaseResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation releaseWalletHandleTokenAsync.
     *
     * Release a wallet handle token
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ReleaseWalletHandleTokenRequest $release_wallet_handle_token_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releaseWalletHandleTokenAsync($release_wallet_handle_token_request)
    {
        return $this->releaseWalletHandleTokenAsyncWithHttpInfo($release_wallet_handle_token_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releaseWalletHandleTokenAsyncWithHttpInfo.
     *
     * Release a wallet handle token
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ReleaseWalletHandleTokenRequest $release_wallet_handle_token_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releaseWalletHandleTokenAsyncWithHttpInfo($release_wallet_handle_token_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletReleaseResponse';
        $request = $this->releaseWalletHandleTokenRequest($release_wallet_handle_token_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releaseWalletHandleToken'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\ReleaseWalletHandleTokenRequest $release_wallet_handle_token_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function releaseWalletHandleTokenRequest($release_wallet_handle_token_request)
    {
        // verify the required parameter 'release_wallet_handle_token_request' is set
        if ($release_wallet_handle_token_request === null || (is_array($release_wallet_handle_token_request) && count($release_wallet_handle_token_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_wallet_handle_token_request when calling releaseWalletHandleToken'
            );
        }

        $resourcePath = '/v1/wallet/release';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($release_wallet_handle_token_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($release_wallet_handle_token_request));
            } else {
                $httpBody = $release_wallet_handle_token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renameWallet.
     *
     * Rename a wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\RenameWalletRequest $rename_wallet_request rename_wallet_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenameResponse
     */
    public function renameWallet($rename_wallet_request)
    {
        list($response) = $this->renameWalletWithHttpInfo($rename_wallet_request);

        return $response;
    }

    /**
     * Operation renameWalletWithHttpInfo.
     *
     * Rename a wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\RenameWalletRequest $rename_wallet_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenameResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function renameWalletWithHttpInfo($rename_wallet_request)
    {
        $request = $this->renameWalletRequest($rename_wallet_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenameResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenameResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenameResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenameResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation renameWalletAsync.
     *
     * Rename a wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\RenameWalletRequest $rename_wallet_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameWalletAsync($rename_wallet_request)
    {
        return $this->renameWalletAsyncWithHttpInfo($rename_wallet_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renameWalletAsyncWithHttpInfo.
     *
     * Rename a wallet
     *
     * @param  \Rootsoft\Algorand\KMD\Model\RenameWalletRequest $rename_wallet_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameWalletAsyncWithHttpInfo($rename_wallet_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenameResponse';
        $request = $this->renameWalletRequest($rename_wallet_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renameWallet'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\RenameWalletRequest $rename_wallet_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function renameWalletRequest($rename_wallet_request)
    {
        // verify the required parameter 'rename_wallet_request' is set
        if ($rename_wallet_request === null || (is_array($rename_wallet_request) && count($rename_wallet_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rename_wallet_request when calling renameWallet'
            );
        }

        $resourcePath = '/v1/wallet/rename';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($rename_wallet_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($rename_wallet_request));
            } else {
                $httpBody = $rename_wallet_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renewWalletHandleToken.
     *
     * Renew a wallet handle token
     *
     * @param  \Rootsoft\Algorand\KMD\Model\RenewWalletHandleTokenRequest $renew_wallet_handle_token_request renew_wallet_handle_token_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenewResponse
     */
    public function renewWalletHandleToken($renew_wallet_handle_token_request)
    {
        list($response) = $this->renewWalletHandleTokenWithHttpInfo($renew_wallet_handle_token_request);

        return $response;
    }

    /**
     * Operation renewWalletHandleTokenWithHttpInfo.
     *
     * Renew a wallet handle token
     *
     * @param  \Rootsoft\Algorand\KMD\Model\RenewWalletHandleTokenRequest $renew_wallet_handle_token_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenewResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function renewWalletHandleTokenWithHttpInfo($renew_wallet_handle_token_request)
    {
        $request = $this->renewWalletHandleTokenRequest($renew_wallet_handle_token_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenewResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenewResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenewResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenewResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation renewWalletHandleTokenAsync.
     *
     * Renew a wallet handle token
     *
     * @param  \Rootsoft\Algorand\KMD\Model\RenewWalletHandleTokenRequest $renew_wallet_handle_token_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renewWalletHandleTokenAsync($renew_wallet_handle_token_request)
    {
        return $this->renewWalletHandleTokenAsyncWithHttpInfo($renew_wallet_handle_token_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renewWalletHandleTokenAsyncWithHttpInfo.
     *
     * Renew a wallet handle token
     *
     * @param  \Rootsoft\Algorand\KMD\Model\RenewWalletHandleTokenRequest $renew_wallet_handle_token_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renewWalletHandleTokenAsyncWithHttpInfo($renew_wallet_handle_token_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTWalletRenewResponse';
        $request = $this->renewWalletHandleTokenRequest($renew_wallet_handle_token_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renewWalletHandleToken'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\RenewWalletHandleTokenRequest $renew_wallet_handle_token_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function renewWalletHandleTokenRequest($renew_wallet_handle_token_request)
    {
        // verify the required parameter 'renew_wallet_handle_token_request' is set
        if ($renew_wallet_handle_token_request === null || (is_array($renew_wallet_handle_token_request) && count($renew_wallet_handle_token_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $renew_wallet_handle_token_request when calling renewWalletHandleToken'
            );
        }

        $resourcePath = '/v1/wallet/renew';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($renew_wallet_handle_token_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($renew_wallet_handle_token_request));
            } else {
                $httpBody = $renew_wallet_handle_token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signMultisigProgram.
     *
     * Sign a program for a multisig account
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignProgramMultisigRequest $sign_multisig_program_request sign_multisig_program_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigProgramSignResponse
     */
    public function signMultisigProgram($sign_multisig_program_request)
    {
        list($response) = $this->signMultisigProgramWithHttpInfo($sign_multisig_program_request);

        return $response;
    }

    /**
     * Operation signMultisigProgramWithHttpInfo.
     *
     * Sign a program for a multisig account
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignProgramMultisigRequest $sign_multisig_program_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigProgramSignResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function signMultisigProgramWithHttpInfo($sign_multisig_program_request)
    {
        $request = $this->signMultisigProgramRequest($sign_multisig_program_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigProgramSignResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigProgramSignResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigProgramSignResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigProgramSignResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation signMultisigProgramAsync.
     *
     * Sign a program for a multisig account
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignProgramMultisigRequest $sign_multisig_program_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signMultisigProgramAsync($sign_multisig_program_request)
    {
        return $this->signMultisigProgramAsyncWithHttpInfo($sign_multisig_program_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signMultisigProgramAsyncWithHttpInfo.
     *
     * Sign a program for a multisig account
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignProgramMultisigRequest $sign_multisig_program_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signMultisigProgramAsyncWithHttpInfo($sign_multisig_program_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigProgramSignResponse';
        $request = $this->signMultisigProgramRequest($sign_multisig_program_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signMultisigProgram'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignProgramMultisigRequest $sign_multisig_program_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function signMultisigProgramRequest($sign_multisig_program_request)
    {
        // verify the required parameter 'sign_multisig_program_request' is set
        if ($sign_multisig_program_request === null || (is_array($sign_multisig_program_request) && count($sign_multisig_program_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sign_multisig_program_request when calling signMultisigProgram'
            );
        }

        $resourcePath = '/v1/multisig/signprogram';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($sign_multisig_program_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($sign_multisig_program_request));
            } else {
                $httpBody = $sign_multisig_program_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signMultisigTransaction.
     *
     * Sign a multisig transaction
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignMultisigRequest $sign_multisig_transaction_request sign_multisig_transaction_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigTransactionSignResponse
     */
    public function signMultisigTransaction($sign_multisig_transaction_request)
    {
        list($response) = $this->signMultisigTransactionWithHttpInfo($sign_multisig_transaction_request);

        return $response;
    }

    /**
     * Operation signMultisigTransactionWithHttpInfo.
     *
     * Sign a multisig transaction
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignMultisigRequest $sign_multisig_transaction_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigTransactionSignResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function signMultisigTransactionWithHttpInfo($sign_multisig_transaction_request)
    {
        $request = $this->signMultisigTransactionRequest($sign_multisig_transaction_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigTransactionSignResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigTransactionSignResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigTransactionSignResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigTransactionSignResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation signMultisigTransactionAsync.
     *
     * Sign a multisig transaction
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignMultisigRequest $sign_multisig_transaction_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signMultisigTransactionAsync($sign_multisig_transaction_request)
    {
        return $this->signMultisigTransactionAsyncWithHttpInfo($sign_multisig_transaction_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signMultisigTransactionAsyncWithHttpInfo.
     *
     * Sign a multisig transaction
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignMultisigRequest $sign_multisig_transaction_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signMultisigTransactionAsyncWithHttpInfo($sign_multisig_transaction_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTMultisigTransactionSignResponse';
        $request = $this->signMultisigTransactionRequest($sign_multisig_transaction_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signMultisigTransaction'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignMultisigRequest $sign_multisig_transaction_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function signMultisigTransactionRequest($sign_multisig_transaction_request)
    {
        // verify the required parameter 'sign_multisig_transaction_request' is set
        if ($sign_multisig_transaction_request === null || (is_array($sign_multisig_transaction_request) && count($sign_multisig_transaction_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sign_multisig_transaction_request when calling signMultisigTransaction'
            );
        }

        $resourcePath = '/v1/multisig/sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($sign_multisig_transaction_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($sign_multisig_transaction_request));
            } else {
                $httpBody = $sign_multisig_transaction_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signProgram.
     *
     * Sign program
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignProgramRequest $sign_program_request sign_program_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTProgramSignResponse
     */
    public function signProgram($sign_program_request)
    {
        list($response) = $this->signProgramWithHttpInfo($sign_program_request);

        return $response;
    }

    /**
     * Operation signProgramWithHttpInfo.
     *
     * Sign program
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignProgramRequest $sign_program_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTProgramSignResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function signProgramWithHttpInfo($sign_program_request)
    {
        $request = $this->signProgramRequest($sign_program_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTProgramSignResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTProgramSignResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTProgramSignResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTProgramSignResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation signProgramAsync.
     *
     * Sign program
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignProgramRequest $sign_program_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signProgramAsync($sign_program_request)
    {
        return $this->signProgramAsyncWithHttpInfo($sign_program_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signProgramAsyncWithHttpInfo.
     *
     * Sign program
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignProgramRequest $sign_program_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signProgramAsyncWithHttpInfo($sign_program_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTProgramSignResponse';
        $request = $this->signProgramRequest($sign_program_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signProgram'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignProgramRequest $sign_program_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function signProgramRequest($sign_program_request)
    {
        // verify the required parameter 'sign_program_request' is set
        if ($sign_program_request === null || (is_array($sign_program_request) && count($sign_program_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sign_program_request when calling signProgram'
            );
        }

        $resourcePath = '/v1/program/sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($sign_program_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($sign_program_request));
            } else {
                $httpBody = $sign_program_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signTransaction.
     *
     * Sign a transaction
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignTransactionRequest $sign_transaction_request sign_transaction_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rootsoft\Algorand\KMD\Model\APIV1POSTTransactionSignResponse
     */
    public function signTransaction($sign_transaction_request)
    {
        list($response) = $this->signTransactionWithHttpInfo($sign_transaction_request);

        return $response;
    }

    /**
     * Operation signTransactionWithHttpInfo.
     *
     * Sign a transaction
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignTransactionRequest $sign_transaction_request (required)
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rootsoft\Algorand\KMD\Model\APIV1POSTTransactionSignResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function signTransactionWithHttpInfo($sign_transaction_request)
    {
        $request = $this->signTransactionRequest($sign_transaction_request);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('\Rootsoft\Algorand\KMD\Model\APIV1POSTTransactionSignResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rootsoft\Algorand\KMD\Model\APIV1POSTTransactionSignResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTTransactionSignResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rootsoft\Algorand\KMD\Model\APIV1POSTTransactionSignResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation signTransactionAsync.
     *
     * Sign a transaction
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignTransactionRequest $sign_transaction_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signTransactionAsync($sign_transaction_request)
    {
        return $this->signTransactionAsyncWithHttpInfo($sign_transaction_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signTransactionAsyncWithHttpInfo.
     *
     * Sign a transaction
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignTransactionRequest $sign_transaction_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signTransactionAsyncWithHttpInfo($sign_transaction_request)
    {
        $returnType = '\Rootsoft\Algorand\KMD\Model\APIV1POSTTransactionSignResponse';
        $request = $this->signTransactionRequest($sign_transaction_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signTransaction'.
     *
     * @param  \Rootsoft\Algorand\KMD\Model\SignTransactionRequest $sign_transaction_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function signTransactionRequest($sign_transaction_request)
    {
        // verify the required parameter 'sign_transaction_request' is set
        if ($sign_transaction_request === null || (is_array($sign_transaction_request) && count($sign_transaction_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sign_transaction_request when calling signTransaction'
            );
        }

        $resourcePath = '/v1/transaction/sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($sign_transaction_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($sign_transaction_request));
            } else {
                $httpBody = $sign_transaction_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation swaggerHandler.
     *
     * Gets the current swagger spec.
     *
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function swaggerHandler()
    {
        list($response) = $this->swaggerHandlerWithHttpInfo();

        return $response;
    }

    /**
     * Operation swaggerHandlerWithHttpInfo.
     *
     * Gets the current swagger spec.
     *
     *
     * @throws \Rootsoft\Algorand\KMD\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function swaggerHandlerWithHttpInfo()
    {
        $request = $this->swaggerHandlerRequest();

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation swaggerHandlerAsync.
     *
     * Gets the current swagger spec.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swaggerHandlerAsync()
    {
        return $this->swaggerHandlerAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation swaggerHandlerAsyncWithHttpInfo.
     *
     * Gets the current swagger spec.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swaggerHandlerAsyncWithHttpInfo()
    {
        $returnType = 'string';
        $request = $this->swaggerHandlerRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'swaggerHandler'.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function swaggerHandlerRequest()
    {
        $resourcePath = '/swagger.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-KMD-API-Token');
        if ($apiKey !== null) {
            $headers['X-KMD-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option.
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (! $options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: '.$this->config->getDebugFile());
            }
        }

        return $options;
    }
}
